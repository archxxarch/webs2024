<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>데이터 실행하기</title>

    <link rel="stylesheet" href="https://webfontworld.github.io/gmarket/GmarketSans.css">
    <link rel="stylesheet" href="https://websfont.github.io/nanumSquareNeo/nanumSquareNeo.css">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="../assets/css/default.min.css">
</head>

<body>
    <div id="wrap">
        <header id="header">
            <h1>
                <a href="index.html">javascript</a>
            </h1>
            <nav>
                <ul>
                    <li><a href="javascript01.html">데이터 저장하기</a></li>
                    <li><a href="javascript02.html">데이터 불러오기</a></li>
                    <li class="active"><a href="javascript03.html">데이터 실행하기</a></li>
                    <li><a href="javascript04.html">데이터 제어하기</a></li>
                </ul>
                <ul>
                    <li><a href="javascript05.html">문자열 객체</a></li>
                    <li><a href="javascript06.html">배열 객체</a></li>
                    <li><a href="javascript07.html">수학 객체</a></li>
                    <li><a href="javascript08.html">브라우저 객체</a></li>
                    <li><a href="javascript09.html">요소 객체</a></li>
                    <li><a href="javascript10.html">이벤트 객체</a></li>
                </ul>
                <ul>
                    <li><a href="javascript11.html">데이터 효과</a></li>
                    <li><a href="javascript12.html">퀴즈 효과</a></li>
                    <li><a href="javascript13.html">마우스 효과</a></li>
                    <li><a href="javascript14.html">슬라이드 효과</a></li>
                </ul>
            </nav>
        </header>
        <!-- //header -->

        <main id="main">
            <div class="main__menu">
                <ul>
                    <li><a href="#">01. 함수 : 선언적 함수</a></li>
                    <li><a href="#">02. 함수 : 익명 함수</a></li>
                    <li><a href="#">03. 함수 : 매개변수 함수</a></li>
                    <li><a href="#">04. 함수 : 리턴값 함수</a></li>
                    <li><a href="#">05. 함수 : 매개변수 + 리턴값 함수</a></li>
                    <li><a href="#">06. 화살표 함수 : 선언적 함수</a></li>
                    <li><a href="#">07. 화살표 함수 : 익명 함수</a></li>
                    <li><a href="#">08. 화살표 함수 : 매개변수 함수</a></li>
                    <li><a href="#">09. 화살표 함수 : 리턴값 함수</a></li>
                    <li><a href="#">10. 화살표 함수 : 매개변수 + 리턴값 함수</a></li>
                    <li><a href="#">11. 함수 유형 : 함수와 매개변수를 이용한 형태</a></li>
                    <li><a href="#">12. 함수 유형 : 함수와 변수를 이용한 형태</a></li>
                    <li><a href="#">13. 함수 유형 : 함수와 배열을 이용한 형태</a></li>
                    <li><a href="#">14. 함수 유형 : 함수와 객체를 이용한 형태</a></li>
                    <li><a href="#">15. 함수 유형 : 함수와 객체 및 배열을 이용한 형태</a></li>
                    <li><a href="#">16. 함수 유형 : 객체 안에 함수를 이용한 형태</a></li>
                    <li><a href="#">17. 함수 유형 : 객체 생성자 함수</a></li>
                    <li><a href="#">18. 함수 유형 : 프로토타입 함수</a></li>
                    <li><a href="#">19. 함수 유형 : 객체 리터럴 함수</a></li>
                    <li><a href="#">20. 함수 : 즉시실행 함수</a></li>
                    <li><a href="#">21. 함수 : 파라미터 함수</a></li>
                    <li><a href="#">22. 함수 : 재귀 함수</a></li>
                    <li><a href="#">23. 함수 : 콜백 함수</a></li>
                    <li><a href="#">24. 함수 : 비동기 함수 : 콜백 함수</a></li>
                    <li><a href="#">25. 함수 : 비동기 함수 : 프로미스</a></li>
                    <li><a href="#">26. 함수 : 비동기 함수 : asyne/await</a></li>
                    <li><a href="#">27. 함수 : 중첩 함수</a></li>
                    <li><a href="#">28. 함수 : 클로저</a></li>
                    <li><a href="#">29. 클래스 : 기본</a></li>
                    <li><a href="#">30. 클래스 : 상속</a></li>
                </ul>
            </div>
            <!-- //main__menu -->

            <div class="main__sample">
                <div id="sample01" class="sample">
                    <h3>01. 함수 : 선언적 함수</h3>
                    <p>자바스크립트(JavaScript)에서 함수는 프로그램 내에서 재사용 가능한 코드 블록을 나타내는 중요한 개념입니다.
                        함수를 사용하면 특정 작업을 수행하는 코드를 논리적으로 묶어서 호출하고 실행할 수 있습니다.
                        이를 통해 코드의 재사용성을 증가시키고 유지보수를 용이하게 만들 수 있습니다.
                        함수는 자체 스코프 내에서 변수를 선언하고, 매개변수를 통해 입력을 받아 작업을 수행하며, 결과를 반환할 수 있습니다.
                        선언적 함수(Declarative Function)는 함수를 선언(정의)할 때 함수의 이름과 매개변수를 사용하여 함수의 구조를 나타내는 방식을 말합니다.
                        이러한 함수 정의 방식은 일반적으로 함수 호이스팅에 영향을 받지 않으며 코드의 가독성을 높이는 데 도움이 됩니다.
                    </p>
                    <pre><code class="language-js">{
    function func(){
        console.log("실행되었습니다.");
    }
    func();
}
</code></pre>
                    <p class="desc">function func(){ ... }: func라는 이름의 함수를 선언합니다. 이 함수는 아무런 매개변수를 가지지 않으며, 함수 내부에서
                        "실행되었습니다."라는 문자열을 콘솔에 출력하는 명령을 포함하고 있습니다.<br>
                        func();: func 함수를 호출합니다.<br>
                        함수가 호출되면 함수 내부의 코드가 실행됩니다. 따라서 "실행되었습니다."라는 문자열이 콘솔에 출력됩니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample01-->

                <div id="sample02" class="sample">
                    <h3>02. 함수 : 익명 함수</h3>
                    <p>익명 함수(Anonymous Function)는 이름 없이 정의된 함수로, 함수 선언 시 함수의 이름이 없는 함수입니다. 익명 함수는 주로 다른 함수의 매개변수로 전달하거나
                        변수에 할당되어 사용되는 경우가 많습니다. 익명 함수는 특히 한 번만 사용될 함수나 특정 컨텍스트에서만 필요한 함수를 간단하게 정의할 때 유용합니다. 그러나 가독성을 위해
                        가능한 한 선언적 함수를 사용하는 것이 좋습니다.</p>
                    <pre><code class="language-js">{
    const func = function (){
        console.log("실행되었습니다.");
    }
    func();
}
</code></pre>
                    <p class="desc">func라는 이름의 변수에 익명 함수를 할당합니다. 이 익명 함수는 아무런 매개변수를 받지 않으며, 함수 내부에서 "실행되었습니다."라는 문자열을
                        콘솔에 출력하는 명령을 포함하고 있습니다.<br>
                        그 다음으로 func 함수를 호출합니다.<br>
                        함수가 호출되면 함수 내부의 코드가 실행됩니다. 따라서 "실행되었습니다."라는 문자열이 콘솔에 출력됩니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample02-->

                <div id="sample03" class="sample">
                    <h3>03. 함수 : 매개변수 함수</h3>
                    <p>매개변수 함수는 일반적으로 다른 함수에 전달되는 함수를 의미합니다. 이는 함수형 프로그래밍 패러다임에서 주로 사용되며, 콜백 함수, 프로미스, 배열의 메서드와 같은 곳에서
                        자주 볼 수 있는 개념입니다. 매개변수 함수를 사용하면 함수의 동작을 동적으로 변경하거나 조합할 수 있습니다. 이는 코드의 재사용성과 유연성을 높이는 데 도움이 됩니다.
                    </p>
                    <pre><code class="language-js">{
    function func(str){
        console.log(str);
    }
    func("실행되었습니다.");
}
</code></pre>
                    <p class="desc">function func(str){ ... }: func라는 이름의 함수를 선언합니다. 이 함수는 하나의 매개변수 str을 받으며, 함수 내부에서 받은
                        str 값을 콘솔에 출력하는 명령을 포함하고 있습니다.<br>
                        func("실행되었습니다.");: func 함수를 호출하면서 문자열 "실행되었습니다."를 인자로 전달합니다.<br>
                        함수가 호출되면 전달된 인자가 str 매개변수로 전달되고, 함수 내부에서는 해당 문자열이 콘솔에 출력됩니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample03-->

                <div id="sample04" class="sample">
                    <h3>04. 함수 : 리턴값 함수</h3>
                    <p>리턴값 함수는 함수 내부에서 어떤 연산을 수행한 후 그 결과를 반환하는 함수를 의미합니다.
                        함수는 종종 입력값을 처리하고 그에 따라 계산된 값을 반환합니다. 이렇게 반환되는 값은 함수 외부에서 사용할 수 있습니다.
                        리턴값(결과/종료)이 있는 함수는 return 제어문을 사용해서 함수의 연산 결과 중 원하는 값을 지정해서 호출위치로 복구시키는 기능을 말합니다.
                        리턴값 함수를 사용하면 함수의 연산 결과를 변수에 할당하거나 다른 함수의 인수로 전달할 수 있습니다.
                        이를 통해 함수 간에 데이터를 주고받거나 연산을 조합할 수 있습니다.

                    </p>
                    <pre><code class="language-js">{
    function func(){
        return "실행되었습니다.";
    }
    console.log(func());
}
</code></pre>
                    <p class="desc">function func(){ ... }: func라는 이름의 함수를 선언합니다. 이 함수는 아무런 매개변수를 받지 않으며, 함수 내부에서
                        "실행되었습니다."라는 문자열을 반환합니다.<br>
                        func(): func 함수를 호출합니다.<br>
                        함수가 호출되면 함수 내부의 코드가 실행됩니다. 이 경우 함수 내부에서 문자열 "실행되었습니다."가 반환됩니다.<br>
                        console.log(func());: 함수의 반환값을 console.log를 사용하여 콘솔에 출력합니다. 즉, 함수가 반환한 문자열 "실행되었습니다."가 콘솔에
                        출력됩니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample04-->

                <div id="sample05" class="sample">
                    <h3>05. 함수 : 매개변수 + 리턴값 함수</h3>
                    <p>매개변수 함수는 일반적으로 다른 함수에 전달되는 함수를 의미합니다.
                        이는 함수형 프로그래밍 패러다임에서 주로 사용되며, 콜백 함수, 프로미스, 배열의 메서드와 같은 곳에서 자주 볼 수 있는 개념입니다.
                        리턴값 함수는 함수 내부에서 어떤 연산을 수행한 후 그 결과를 반환하는 함수를 의미합니다. 함수는 종종 입력값을 처리하고 그에 따라 계산된 값을 반환합니다. 이렇게 반환되는
                        값은 함수 외부에서 사용할 수 있습니다.
                        리턴값(결과/종료)이 있는 함수는 return 제어문을 사용해서 함수의 연산 결과 중 원하는 값을 지정해서 호출위치로 복구시키는 기능을 말합니다.
                        매개변수를 받아 처리하는 함수와 그 결과를 반환하는 함수를 조합하면, 더 복잡한 작업을 수행하고 코드를 모듈화하여 관리하기 쉬운 구조를 만들 수 있습니다.
                    </p>
                    <pre><code class="language-js">{
    function func(str){
        return str;
    }
    console.log(func("실행되었습니다."));
}
</code></pre>
                    <p class="desc">function func(str){ ... }: func라는 이름의 함수를 선언합니다. 이 함수는 하나의 매개변수 str을 받으며, 함수 내부에서 받은
                        str 값을 그대로 반환합니다.<br>
                        func("실행되었습니다.");: func 함수를 호출하면서 문자열 "실행되었습니다."를 인자로 전달합니다.<br>
                        함수가 호출되면 전달된 인자인 "실행되었습니다."가 str 매개변수로 전달되고, 함수 내부에서는 이 문자열이 그대로 반환됩니다.<br>
                        console.log(func("실행되었습니다."));: 함수의 반환값을 console.log를 사용하여 콘솔에 출력합니다. 즉, 함수가 반환한 "실행되었습니다." 문자열이
                        콘솔에 출력됩니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample05-->

                <div id="sample06" class="sample">
                    <h3>06. 화살표 함수 : 선언적 함수</h3>
                    <p>화살표 함수는 function 키워드를 사용하지 않고 => 기호로 함수를 정의합니다.
                        이렇게 하면 함수의 구현 내용이 간결해지고 코드를 더 읽기 쉽게 만들 수 있습니다.
                        또한 화살표 함수는 주변 스코프의 this 값을 상속하기 때문에 특정 상황에서 유용합니다.</p>
                    <pre><code class="language-js">{
    func = () => {
        console.log("실행되었습니다.");
    }
    func();
}
</code></pre>
                    <p class="desc">func = () => { ... }: func라는 변수에 화살표 함수를 할당합니다. 이 화살표 함수는 매개변수가 없으며, 함수 내부에서
                        "실행되었습니다."라는 문자열을 콘솔에 출력하는 명령을 포함하고 있습니다.<br>
                        func();: func 변수에 할당된 화살표 함수를 호출합니다.<br>
                        함수가 호출되면 함수 내부의 코드가 실행됩니다. 따라서 "실행되었습니다."라는 문자열이 콘솔에 출력됩니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample06-->

                <div id="sample07" class="sample">
                    <h3>07. 화살표 함수 : 익명 함수</h3>
                    <p>익명 함수란 함수의 이름을 가지지 않는 함수를 의미하며, 주로 변수에 할당되거나 다른 함수의 매개변수로 전달되는 함수로 사용됩니다.
                        화살표 함수는 이러한 익명 함수를 간결하게 표현하는 데 사용됩니다.</p>
                    <pre><code class="language-js">{
    const func = () => {
        console.log("실행되었습니다.");
    }
    func();
}
</code></pre>
                    <p class="desc">const func = () => { ... }: func라는 이름의 변수에 화살표 함수를 할당합니다. 이 화살표 함수는 매개변수를 받지 않으며, 함수
                        내부에서 "실행되었습니다."라는 문자열을 콘솔에 출력하는 명령을 포함하고 있습니다.<br>
                        func();: func 변수에 할당된 화살표 함수를 호출합니다.<br>
                        함수가 호출되면 함수 내부의 코드가 실행됩니다. 따라서 "실행되었습니다."라는 문자열이 콘솔에 출력됩니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample07-->

                <div id="sample08" class="sample">
                    <h3>08. 화살표 함수 : 매개변수 함수</h3>
                    <p>화살표 함수(arrow function)를 사용하여 매개변수 함수를 정의하는 것은 JavaScript에서 일반적으로 콜백 함수 또는 다른 함수에 전달되는 함수를 간결하게
                        작성하는 데 유용한 기술 중 하나입니다.
                        이렇게 정의된 매개변수 함수는 일반적으로 다른 함수 내에서 호출되거나 사용됩니다.
                        매개변수 함수를 화살표 함수로 정의하면 코드를 간결하게 만들 수 있으며, 특히 배열의 map, filter, reduce와 같은 고차 함수(higher-order
                        functions)와 함께 사용할 때 유용합니다.
                    </p>
                    <pre><code class="language-js">{
    func = (str) => {
        console.log(str);
    }
    func("실행되었습니다.");
}
</code></pre>
                    <p class="desc">func = (str) => { ... }: func라는 변수에 매개변수 str을 받는 화살표 함수를 할당합니다. 이 화살표 함수는 함수 내부에서 받은
                        str을 콘솔에 출력하는 명령을 포함하고 있습니다.<br>
                        func("실행되었습니다.");: func 변수에 할당된 화살표 함수를 호출하면서 문자열 "실행되었습니다."를 인자로 전달합니다.<br>
                        함수가 호출되면 전달된 인자 "실행되었습니다."가 str 매개변수로 전달되고, 함수 내부에서는 이 문자열이 콘솔에 출력됩니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample08-->

                <div id="sample09" class="sample">
                    <h3>09. 화살표 함수 : 리턴값 함수</h3>
                    <p>화살표 함수는 단일 표현식의 결과값을 반환하므로 중괄호 {}를 사용하지 않아도 됩니다. 따라서 간단한 함수를 간결하게 정의할 수 있습니다.
                        화살표 함수는 => 오른쪽의 표현식을 계산하고 그 값을 자동으로 반환합니다. 따라서 return 키워드를 명시적으로 사용하지 않아도 됩니다.
                        한 줄로 표현되는 경우에는 중괄호 {}를 생략하고 표현식만 사용할 수 있습니다. 그렇게 되면 그 표현식의 결과가 자동으로 반환됩니다.
                    </p>
                    <pre><code class="language-js">{
    func = (str) => {
        return "실행되었습니다.";
    }
    console.log(func());
}
</code></pre>
                    <p class="desc">func = (str) => { ... }: func라는 변수에 화살표 함수를 할당합니다. 이 화살표 함수는 하나의 매개변수 str을 받고, 함수
                        내부에서 "실행되었습니다."라는 문자열을 리턴합니다.<br>
                        console.log(func());: func 변수에 할당된 화살표 함수를 호출합니다. 이 때 인자를 전달하지 않으므로 str 매개변수는 undefined가
                        됩니다.<br>
                        함수가 호출되면 함수 내부의 코드가 실행됩니다. 화살표 함수 내에서 "실행되었습니다." 문자열이 리턴됩니다.<br>
                        console.log를 사용하여 함수의 리턴값을 콘솔에 출력합니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample09-->

                <div id="sample10" class="sample">
                    <h3>10. 화살표 함수 : 매개변수 + 리턴값 함수</h3>
                    <p></p>
                    <pre><code class="language-js">{
    // 10-1. 익명 함수
    const func = (str) => {
        return str;
    }
    console.log(func("실행되었습니다.1"));

    //10-2.  괄호 생략
    const func2 = str => {
        return str;
    }
    console.log(func2("실행되었습니다.2"));

    // 10-3. 리턴 생략
    const func3 = str => str;
    
    console.log(func3("실행되었습니다.3"));

    // 10-4. 선언적(가독성X)
    func4 = str => str;
    
    console.log(func4("실행되었습니다.4"));
}
</code></pre>
                    <p class="desc">
                        10-1. 화살표 함수(arrow function)는 주로 익명 함수(anonymous function)로 사용되는 함수 표현식입니다. 따라서 화살표 함수를 익명 함수로
                        나타내려면 화살표 함수의 이름이 없는 특성을 감안하여 변수에 할당하거나 다른 함수의 매개변수로 전달하는 방식으로 사용합니다.
                        익명 함수로 표현된 화살표 함수와 일반적인 함수 표현식 간의 차이점은 주로 문법적이며, 기능적으로 동일한 작업을 수행합니다. 함수를 익명 함수로 나타내면 함수가 변수에
                        할당되거나 다른 함수에 전달되는 등의 상황에서 유용하게 사용됩니다.<br>
                        10-2. 화살표 함수에서 중괄호 {}를 생략한 형태를 말하는 것으로, 이 형태의 화살표 함수는 단일 표현식을 평가하고 그 결과를 자동으로 반환합니다. 이 형태의 화살표
                        함수를 사용하면 함수 정의를 더 간결하게 만들 수 있습니다.중괄호 {}를 생략한 경우, 함수 본문이 한 줄의 표현식으로 표현됩니다. 이 경우에는 중괄호와 return
                        키워드를 생략할 수 있습니다.
                        중괄호를 생략한 화살표 함수는 주로 간단한 작업을 수행하거나, 함수 표현식을 간결하게 표현하려는 경우에 사용됩니다. 하지만 함수 본문이 복잡하거나 여러 문장으로 이루어져
                        있는 경우에는 중괄호를 사용하여 명시적으로 함수 본문을 정의하는 것이 좋습니다. <br>


                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                실행되었습니다.1<br>
                                실행되었습니다.2<br>
                                실행되었습니다.3<br>
                                실행되었습니다.4<br>
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample10-->

                <div id="sample11" class="sample">
                    <h3>11. 함수 유형 : 함수와 매개변수를 이용한 형태</h3>
                    <p>이 함수는 입력값(매개변수)을 받아서 처리하고 결과값을 반환하는 기능을 수행합니다. </p>
                    <pre><code class="language-js">{
    function func(num, str){
        console.log(`${num}. ${str}`);
        console.log(num + ". " + str);
    }
    func(11, "함수가 실행되었습니다.");
}
</code></pre>
                    <p class="desc">
                        console.log(`${num}. ${str}`); : 자열 템플릿 리터럴을 사용하여 화면에 문자열을 출력하는 명령문입니다.<br>
                        console.log(num + ". " + str); : 이 줄은 문자열 연결 연산자(+)를 사용하여 화면에 문자열을 출력하는 명령문입니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                11. 함수가 실행되었습니다.<br>
                                11. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample11-->

                <div id="sample12" class="sample">
                    <h3>12. 함수 유형 : 함수와 변수를 이용한 형태</h3>
                    <p>함수와 변수를 이용한 형태의 함수는 변수를 활용하여 함수 내부에서 값을 저장하거나 계산에 활용하는 함수입니다. 이러한 함수는 주로 중간 결과를 저장하거나 재사용 가능한 코드
                        블록을 구현하는 데 사용됩니다. </p>
                    <pre><code class="language-js">{
    const num = 12;
    const str = "함수가 실행되었습니다.";

    function func(num, str){
        console.log(`${num}. ${str}`);
    }
    func(num, str);
}
</code></pre>
                    <p class="desc">
                        const num = 12;, const str = "함수가 실행되었습니다."; : num, str이라는 이름의 상수 변수를 선언하고 값 12, 함수가 실행되었습니다.을
                        각각 할당합니다. 이 변수는 전역 범위에서 사용 가능합니다.<br>
                        func이라는 이름의 함수를 정의합니다. 이 함수는 매개변수 num과 str을 받습니다.<br>
                        function func(num, str) : 함수 내부에서 num과 str 매개변수를 사용할 것입니다. 이 매개변수는 함수 내에서 전역 범위의 num과 str 변수와는
                        별개로 동작합니다.<br>
                        console.log(`${num}. ${str}`); : 함수 내부에서 문자열 템플릿 리터럴을 사용하여 num과 str을 결합하여 출력합니다. ${num}은 함수 내부의
                        num 매개변수를 참조하며, ${str}은 함수 내부의 str 매개변수를 참조합니다.

                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                12. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample12-->

                <div id="sample13" class="sample">
                    <h3>13. 함수 유형 : 함수와 배열을 이용한 형태</h3>
                    <p>함수와 배열을 이용한 형태의 함수는 배열을 입력값으로 받아서 배열 내부의 요소를 처리하거나 변환하는 함수입니다. 이러한 함수는 배열을 다루는 여러 작업을 모듈화하고 재사용
                        가능한 함수로 구현할 때 유용합니다.</p>
                    <pre><code class="language-js">{
    const num = [13, 14];
    const str = ["함수가 실행되었습니다.", "함수가 실행되었습니다."];

    function func(num, str){
        console.log(`${num}. ${str}`);
    }
    func(num[0], str[0]);
    func(num[1], str[1]);
}
</code></pre>
                    <p class="desc">
                        function func(num, str) : func이라는 이름의 함수를 정의합니다. 이 함수는 매개변수 num과 str을 받습니다. 함수 내부에서 num과 str
                        매개변수를 사용할 것입니다. 이 매개변수는 함수 내에서 전역 범위의 num과 str 배열과는 별개로 동작합니다.<br>
                        console.log(${num}. ${str}); : 함수 내부에서 문자열 템플릿 리터럴을 사용하여 num과 str을 결합하여 출력합니다. ${num}은 함수 내부의
                        num 매개변수를 참조하며, ${str}은 함수 내부의 str 매개변수를 참조합니다.<br>
                        func(num[0], str[0]); : func 함수를 첫 번째 요소인 num[0]과 첫 번째 요소인 str[0]를 인자로 호출합니다. num[0]는 13,
                        str[0]는 "함수가 실행되었습니다."이므로, 함수는 "13. 함수가 실행되었습니다" 문자열을 출력합니다.<br>
                        func(num[1], str[1]); : func 함수를 두 번째 요소인 num[1]과 두 번째 요소인 str[1]를 인자로 호출합니다. num[1]는 14,
                        str[1]는 "함수가 실행되었습니다."이므로, 함수는 "14. 함수가 실행되었습니다" 문자열을 출력합니다.


                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                13. 함수가 실행되었습니다.<br>
                                14. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample13-->

                <div id="sample14" class="sample">
                    <h3>14. 함수 유형 : 함수와 객체를 이용한 형태</h3>
                    <p>함수와 객체를 이용한 형태의 함수는 객체를 입력값으로 받아서 객체 내부의 속성을 처리하거나 조작하는 함수입니다. 이러한 함수는 객체를 다루는 작업을 모듈화하고 재사용 가능한
                        함수로 구현할 때 유용합니다. </p>
                    <pre><code class="language-js">{
    const info = {
        num : 15,
        str : "함수가 실행되었습니다."
    }
    function func(num, str){
        console.log(`${num}. ${str}`);
    }
    func(info.num, info.str);
}
</code></pre>
                    <p class="desc">
                        const info = { num: 15, str: "함수가 실행되었습니다." }; : info라는 이름의 상수 객체를 정의합니다. 이 객체는 num과 str 두 개의
                        속성을 가지고 있습니다. num 속성에는 숫자 15가 할당되고, str 속성에는 문자열 "함수가 실행되었습니다."가 할당됩니다.<br>
                        func(info.num, info.str); : func 함수를 호출합니다. 이 때, 객체 info 내의 num과 str 속성을 인자로 전달합니다. info.num은
                        15, info.str은 "함수가 실행되었습니다."이므로, 함수는 "15. 함수가 실행되었습니다." 문자열을 출력합니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                15. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample14-->

                <div id="sample15" class="sample">
                    <h3>15. 함수 유형 : 함수와 객체 및 배열을 이용한 형태</h3>
                    <p>함수와 객체 및 배열을 이용한 형태의 함수는 함수가 객체와 배열을 조작하거나 처리하는데 사용됩니다. 이러한 함수는 객체와 배열을 조작하여 원하는 결과를 생성하거나 반환하는
                        작업에 사용됩니다. </p>
                    <pre><code class="language-js">{
    const info = [
        {num : 16, str: "함수가 실행되었습니다."},
        {num : 17, str: "함수가 실행되었습니다."},
    ];
    function func(num, str){
        console.log(`${num}. ${str}`);
    }
    func(info[0].num, info[0].str);
    func(info[1].num, info[1].str);
}
</code></pre>
                    <p class="desc">
                        const info = [ {num : 16, str: "함수가 실행되었습니다."}, {num : 17, str: "함수가 실행되었습니다."} ]; : info라는 이름의
                        상수 배열을 정의합니다. 이 배열은 두 개의 객체를 요소로 가지고 있습니다. 각 객체는 num과 str 두 개의 속성을 가지고 있으며, 두 객체는 서로 다른 값을
                        가집니다.<br>
                        func(info[0].num, info[0].str); : func 함수를 호출합니다. 이 때, 배열 info의 첫 번째 요소인 객체에서 num과 str 속성 값을 인자로
                        전달합니다. info[0].num은 16, info[0].str은 "함수가 실행되었습니다."이므로, 함수는 "16. 함수가 실행되었습니다." 문자열을 출력합니다.<br>
                        func(info[1].num, info[1].str); : func 함수를 호출합니다. 이번에는 배열 info의 두 번째 요소인 객체에서 num과 str 속성 값을 인자로
                        전달합니다. info[1].num은 17, info[1].str은 "함수가 실행되었습니다."이므로, 함수는 "17. 함수가 실행되었습니다." 문자열을 출력합니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                16. 함수가 실행되었습니다.<br>
                                17. 함수가 실행되었습니다.

                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample15-->

                <div id="sample16" class="sample">
                    <h3>16. 함수 유형 : 객체 안에 함수를 이용한 형태</h3>
                    <p>객체 안에 함수를 이용한 형태의 함수는 메서드(method)라고도 불립니다. 객체 내에 함수를 포함시켜 해당 객체와 관련된 동작 및 기능을 하나의 단위로 묶는데 사용됩니다.
                    </p>
                    <pre><code class="language-js">{
    const info = {
        num: 18,
        str: "함수가 실행되었습니다.",
        result: () => {
            console.log(`${info.num}. ${info.str}`);
        }
    }
    info.result();
}
</code></pre>
                    <p class="desc">
                        result: () => { console.log(${info.num}. ${info.str}); } : result 속성에는 화살표 함수가 정의되어 있습니다. 이 함수는
                        객체 info 내의 num과 str 속성을 활용하여 문자열을 출력합니다.<br>
                        info.result(); : info 객체의 result 메서드를 호출합니다. 이 메서드 내부에서는 화살표 함수를 사용하여 info.num과 info.str 속성을
                        참조하여 문자열을 출력합니다. 결과적으로, 함수 호출은 "18. 함수가 실행되었습니다. "문자열을 출력합니다:
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                18. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample16-->

                <div id="sample17" class="sample">
                    <h3>17. 함수 유형 : 객체 생성자 함수</h3>
                    <p>객체 생성자 함수(Constructor Function)는 객체를 생성하기 위한 특별한 유형의 함수입니다. 이 함수를 사용하여 동일한 구조의 여러 객체를 생성할 수 있으며,
                        객체 생성 시 초기 상태를 설정할 수 있습니다. </p>
                    <pre><code class="language-js">{
    function Func(num, str){
        this.num = num;
        this.str = str;
        this.result = () => {
            console.log(`${this.num}. ${this.str}`);
        }
    } 

    // 인스턴스 생성
    const info1 = new Func(19, "함수가 실행되었습니다.");
    const info2 = new Func(20, "함수가 실행되었습니다.");

    // 호출
    info1.result();
    info2.result();
}
</code></pre>
                    <p class="desc">
                        function Func(num, str) : Func라는 이름의 객체 생성자 함수를 정의합니다. 이 함수는 두 개의 매개변수 num과 str을 받습니다.<br>
                        this.num = num;, this.str = str; : 함수 내에서 this 키워드를 사용하여 객체의 속성 num과 str을 정의하고, 매개변수로 전달된 값들을
                        할당합니다.<br>
                        this.result = () => { console.log(${this.num}. ${this.str}); } : 함수 내에서 this 키워드를 사용하여 객체의
                        result 속성을 정의합니다. 이 속성에는 화살표 함수가 할당됩니다. 화살표 함수 내에서는 객체의 num과 str 속성을 활용하여 문자열을 출력합니다.<br>
                        인스턴스 생성 : Func 생성자 함수를 사용하여 info1이라는 이름의 객체 인스턴스를 생성합니다. 이때, 매개변수로 숫자 19와 문자열 "함수가 실행되었습니다."를
                        전달합니다.<br>
                        호출 : info1 객체의 result 메서드를 호출합니다. 이때, 객체 내부에서 정의한 화살표 함수가 실행됩니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                19. 함수가 실행되었습니다.<br>
                                20. 함수가 실행되었습니다.

                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample17-->

                <div id="sample18" class="sample">
                    <h3>18. 함수 유형 : 프로토타입 함수</h3>
                    <p>프로토타입 함수(Prototype Function)는 객체 지향 프로그래밍의 핵심 개념 중 하나로, 객체 생성자(constructor) 함수로부터 생성된 모든 객체가 공유하는
                        메서드를 정의하는 방법입니다. 이를 통해 모든 인스턴스가 동일한 동작을 공유하고, 메모리를 효율적으로 사용할 수 있습니다.</p>
                    <pre><code class="language-js">{
    function Func(num, str){
        this.num = num;
        this.str = str;
    }

    Func.prototype.result = function(){
        console.log(`${this.num}. ${this.str}`);
    }

    const info1 = new Func(21, "함수가 실행되었습니다.");
    const info2 = new Func(22, "함수가 실행되었습니다.");

    info1.result();
    info2.result();
}
</code></pre>
                    <p class="desc">
                        function Func(num, str) : Func라는 이름의 객체 생성자 함수를 정의합니다. 이 함수는 두 개의 매개변수 num과 str을 받습니다.<br>
                        his.num = num;, this.str = str; : 함수 내에서 this 키워드를 사용하여 객체의 속성 num과 str을 정의하고, 매개변수로 전달된 값들을
                        할당합니다.<br>
                        Func.prototype.result = function() { console.log(${this.num}. ${this.str}); } : Func 생성자 함수의
                        프로토타입 객체(prototype)에 result 메서드를 추가합니다. 이 메서드는 객체 생성자 함수로부터 생성된 모든 객체에서 공유됩니다. result 메서드는 객체의
                        num과 str 속성을 활용하여 문자열을 출력하는 역할을 합니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                21. 함수가 실행되었습니다.<br>
                                22. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample18-->

                <div id="sample19" class="sample">
                    <h3>19. 함수 유형 : 객체 리터럴 함수</h3>
                    <p>객체 리터럴 함수(Object Literal Function)는 객체를 생성하는 간단하고 직접적인 방법 중 하나입니다. 객체 리터럴 함수를 사용하면 객체를 선언하고 초기화할
                        수 있으며, 객체의 속성과 메서드를 정의할 수 있습니다. 이 함수는 객체의 틀을 정의하는 역할을 합니다.</p>
                    <pre><code class="language-js">{
    function Func(num, str){
        this.num = num;
        this.str = str;
    }

    Func.prototype = {
        result1 : function(){
            console.log(`${this.num}. ${this.str}`);
        },
        result2 : function(){
            console.log(`${this.num}. ${this.str}`);
        }
    }

    const info1 = new Func(23, "함수가 실행되었습니다.");
    const info2 = new Func(24, "함수가 실행되었습니다.");

    info1.result1();
    info2.result2();
}
</code></pre>
                    <p class="desc">
                        function Func(num, str) : Func라는 이름의 객체 생성자 함수를 정의합니다. 이 함수는 두 개의 매개변수 num과 str을 받습니다.<br>
                        this.num = num, ;this.str = str; : 함수 내에서 this 키워드를 사용하여 객체의 속성 num과 str을 정의하고, 매개변수로 전달된 값들을
                        할당합니다.<br>
                        Func.prototype = { result1: function() { /* ... */ }, result2: function() { /* ... */ } } : Func
                        생성자 함수의 프로토타입 객체(prototype)에 객체 리터럴을 사용하여 result1 및 result2 두 개의 메서드를 정의합니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                23. 함수가 실행되었습니다.<br>
                                24. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample19-->

                <div id="sample20" class="sample">
                    <h3>20. 함수 : 즉시실행 함수</h3>
                    <p>즉시 실행 함수(IIFE, Immediately Invoked Function Expression)는 JavaScript에서 사용되는 익명 함수를 정의하고 즉시 실행하는 패턴입니다. 이 패턴은 함수 스코프를 생성하여 변수의 스코프를 제한하고, 전역 네임스페이스 오염을 방지하며 코드 모듈화를 지원하는 등의 목적으로 사용됩니다.</p>
<pre><code class="language-js">
{
    (function () {
        console.log("25. 함수가 실행되었습니다.");
    })();
}

{
    (() => {
        console.log("26. 함수가 실행되었습니다.");
    })();
}
</code></pre>
                    <p class="desc">
                        첫번째 함수에서는 익명 함수를 정의하고 즉시 실행합니다. 함수 내부에서 "25. 함수가 실행되었습니다."라는 메시지가 콘솔에 출력됩니다. 이 코드는 함수 표현식을 사용하여 함수를 정의하고, 그 즉시 실행합니다.<br>
                        두번째 함수에서는 화살표 함수를 사용하여 익명 함수를 정의하고 즉시 실행합니다. 이 역시 함수 내부에서 "26. 함수가 실행되었습니다."라는 메시지를 콘솔에 출력합니다. 이 코드는 화살표 함수를 사용하여 함수를 정의하고, 그 즉시 실행합니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                25. 함수가 실행되었습니다.<br>
                                26. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample20-->

                <div id="sample21" class="sample">
                    <h3>21. 함수 : 파라미터 함수</h3>
                    <p>파라미터 함수(Parametric Function)란 함수가 입력값으로 하나 이상의 파라미터(매개변수)를 받는 함수를 의미합니다. 파라미터 함수는 입력값을 받아서 그 값에 기초하여 작업을 수행하고 결과를 반환하는 데 사용됩니다.</p>
<pre><code class="language-js">
{
    function func(str = "27. 함수가 실행되었습니다.") {
        console.log(str);
    }
    func();

    const func1 = (str = "28. 함수가 실행되었습니다.") => {
        console.log(str);
    }
    func1();
}
</code></pre>
                    <p class="desc">
                        첫번쨰 함수에서는 func라는 이름의 함수를 정의하고, str이라는 파라미터(매개변수)를 가집니다. 파라미터 str은 기본값으로 "27. 함수가 실행되었습니다." 문자열을 가지고 있습니다. 함수 내부에서 console.log를 사용하여 파라미터 str 값을 출력합니다. 함수를 호출할 때 아무 값도 전달하지 않았으므로 기본값인 "27. 함수가 실행되었습니다."가 출력됩니다.<br>
                        두번쨰 함수에서는 func1이라는 이름의 화살표 함수를 정의하고, str이라는 파라미터(매개변수)를 가집니다. 파라미터 str은 기본값으로 "28. 함수가 실행되었습니다." 문자열을 가지고 있습니다. 화살표 함수 내부에서도 console.log를 사용하여 파라미터 str 값을 출력합니다. 함수를 호출할 때 아무 값도 전달하지 않았으므로 기본값인 "28. 함수가 실행되었습니다."가 출력됩니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                27. 함수가 실행되었습니다.<br>
                                28. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample21-->

                <div id="sample22" class="sample">
                    <h3>22. 함수 : 재귀 함수 : 자기 자신을 호출하는 함수</h3>
                    <p>재귀 함수(Recursive Function)는 자기 자신을 호출하는 함수를 의미합니다. 재귀 함수는 일반적으로 문제를 더 작은 하위 문제로 나누어 해결할 때 유용하며, 특히 반복문으로 해결하기 어려운 문제에 사용됩니다. 재귀 함수의 중요한 특징은 종료 조건을 가져야 하며, 재귀 호출이 종료 조건을 만족하게 되면 재귀 호출이 중단됩니다.</p>
<pre><code class="language-js">
{
    function func(num) {
        for (let i = 1; i &lt;= num; i++) {
            console.log("29. 함수가 실행되었습니다.");
        }
    }
    func(10);

    function func1(num) {
        if (num &lt; 1) return;

        console.log("30. 함수가 실행되었습니다.");
        func1(num - 1);
    }
    func1(10);
}
</code></pre>
                    <p class="desc">
                        첫번째 함수에서는 func라는 이름의 함수를 정의하고 num이라는 파라미터(매개변수)를 가집니다. 이 함수는 for 반복문을 사용하여 1부터 num까지 "29. 함수가 실행되었습니다."라는 메시지를 여러 번 출력합니다. 함수를 호출할 때 num에 10을 전달하였으므로, "29. 함수가 실행되었습니다." 메시지가 10번 출력됩니다.<br>
                        두번째 함수에서는 func1이라는 이름의 함수를 정의하고 num이라는 파라미터(매개변수)를 가집니다. 이 함수는 재귀 호출을 사용하여 num이 1보다 작거나 같을 때까지 "30. 함수가 실행되었습니다."라는 메시지를 출력합니다. 재귀 호출은 함수 내에서 자신을 호출하는 것으로, func1(num - 1)을 통해 num 값을 하나씩 감소시키면서 함수를 호출합니다. 종료 조건인 num &lt; 1이 만족되면 재귀 호출이 중단됩니다. 함수를 호출할 때 num에 10을 전달하였으므로, "30. 함수가 실행되었습니다." 메시지가 num 값인 10번 출력되며, 재귀 호출을 통해 출력이 반복됩니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                29. 함수가 실행되었습니다.<br>
                                30. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample22-->

                <div id="sample23" class="sample">
                    <h3>23. 함수 : 콜백 함수 : 다른 함수로 실행되는 함수</h3>
                    <p>콜백 함수(Callback Function)는 JavaScript에서 다른 함수로 전달되고 필요한 시점에 실행되는 함수를 말합니다. 이것은 함수를 매개변수로 전달하고, 특정 이벤트가 발생하거나 조건이 충족될 때 실행되도록 할 때 주로 사용됩니다.</p>
<pre><code class="language-js">
{
    // 01. 이벤트 콜백 함수
    // function func(){
    //     console.log("31. 함수가 실행되었습니다.");
    // }
    // btn.addEventListerner("click", func);

    // 02. 함수를 다른 함수의 인자로 전달
    function func1() {
        console.log("32. 함수가 실행되었습니다.");
    }
    function func2(callback) {
        callback();
        // func1();
    }
    func2(func1);

    // 03. 반복문으로 콜백함수 만들기
    function func3(num) {
        console.log(num + ". 함수가 실행되었습니다.");
    }
    function func4(callback) {
        for (let i = 33; i &lt;= 38; i++) {
            callback(i);
        }
    }
    func4(func3);
}
</code></pre>
                    <p class="desc">
                        01. 주석을 해제하고 이벤트 리스너에 등록하면 버튼 클릭 시 "31. 함수가 실행되었습니다." 메시지가 출력됩니다.<br>
                        02. func1 함수는 func2 함수에 인자로 전달되어 실행됩니다. 따라서 "32. 함수가 실행되었습니다."라는 메시지가 출력됩니다.<br>
                        03. func4 함수는 func3 함수를 여러 번 호출합니다. func3 함수는 각 호출마다 num 값을 출력하므로 num 값은 33부터 38까지 출력됩니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                31. 함수가 실행되었습니다.<br>
                                32. 함수가 실행되었습니다.<br>
                                33. 함수가 실행되었습니다.<br>
                                34. 함수가 실행되었습니다.<br>
                                35. 함수가 실행되었습니다.<br>
                                36. 함수가 실행되었습니다.<br>
                                37. 함수가 실행되었습니다.<br>
                                38. 함수가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample23-->

                <div id="sample24" class="sample">
                    <h3>24. 함수 : 비동기 함수 : 콜백 함수</h3>
                    <p>비동기 함수(Asynchronous Function)는 동기적으로 실행되지 않고, 특정 이벤트, 작업 완료, 타이머 등을 기다리는 동안 다른 코드를 실행할 수 있는 함수를 의미합니다. 이러한 함수들은 자바스크립트의 비동기 프로그래밍에서 중요한 역할을 합니다. 비동기 함수는 주로 콜백 함수를 사용하여 작업이 완료되었을 때 실행되도록 설계됩니다.</p>
<pre><code class="language-js">
{
    // 01. 동기적인 함수 호출
    function func1() {
        console.log("39. 함수가 실행되었습니다.");
    }
    function func2() {
        console.log("40. 함수가 실행되었습니다.");
    }
    func1();
    func2();

    // 02. 비동기적인 함수 호출
    function func3() {
        setTimeout(() => {
            console.log("41. 함수가 실행되었습니다.");
        }, 1000);
    }
    function func4() {
        console.log("42. 함수가 실행되었습니다.");
    }
    func3();
    func4();

    // 03. 비동기적인 콜백 함수 호출
    {
        function func5(callback) {
            setTimeout(() => {
                console.log("43. 함수가 실행되었습니다.");
                callback();
            }, 1000);
        }
        function func6() {
            console.log("44. 함수가 실행되었습니다.");
        }
        func5(function () {
            func6();
        });
    }

    // 04. 콜백 지우기
    {
        function funcA(callback){
            setTimeout(() => {
                console.log("funcA가 실행되었습니다.");
                callback();
            }, 1000);
        }
        function funcB(callback){
            setTimeout(() => {
                console.log("funcB가 실행되었습니다.");
                callback();
            }, 1000);
        }
        function funcC(callback){
            setTimeout(() => {
                console.log("funcC가 실행되었습니다.");
                callback();
            }, 1000);
        }
        function funcD(){
            setTimeout(() => {
                console.log("funcD가 실행되었습니다.");
            }, 1000);
        }
        funcA(function(){
            funcB(function(){
                funcC(function(){
                    funcD();
                });
            });
        });
    }
}
</code></pre>
                    <p class="desc">
                        01. func1과 func2 함수는 동기적으로 호출되며, 순서대로 실행됩니다. 따라서 "39. 함수가 실행되었습니다."와 "40. 함수가 실행되었습니다."라는 메시지가 순서대로 출력됩니다.<br>
                        02. func3 함수는 setTimeout을 사용하여 비동기적으로 실행되며, 1초 후에 "41. 함수가 실행되었습니다."라는 메시지가 출력됩니다. 그러나 func4 함수는 동기적으로 호출되어 "42. 함수가 실행되었습니다."가 먼저 출력되고, 그 다음에 "41. 함수가 실행되었습니다."가 출력됩니다.<br>
                        03. func5 함수는 비동기적으로 실행되며, 1초 후에 "43. 함수가 실행되었습니다."라는 메시지가 출력됩니다. 그리고 콜백 함수 내에서 func6 함수가 호출되어 "44. 함수가 실행되었습니다."가 출력됩니다.<br>
                        04. 콜백 함수를 중첩하여 사용하여 비동기 작업의 실행 순서를 관리하는 예제입니다. funcA 함수는 1초 후에 "funcA가 실행되었습니다."라는 메시지를 출력합니다. 그리고 callback 파라미터로 전달된 콜백 함수를 호출합니다.각 함수는 setTimeout 함수를 사용하여 1초 후에 실행되며, 콜백 함수를 호출하여 다음 함수가 실행되도록 합니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                39. 함수가 실행되었습니다.<br>
                                40. 함수가 실행되었습니다.<br>
                                42. 함수가 실행되었습니다.<br>
                                41. 함수가 실행되었습니다.<br>
                                43. 함수가 실행되었습니다.<br>
                                44. 함수가 실행되었습니다.<br>
                                funcA가 실행되었습니다.<br>
                                funcB가 실행되었습니다.<br>
                                funcC가 실행되었습니다.<br>
                                funcD가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample24-->

                <div id="sample25" class="sample">
                    <h3>25. 함수 : 비동기 함수 : 프로미스</h3>
                    <p>비동기 함수를 다룰 때 콜백 함수 외에도 프로미스(Promise)라는 더 현대적인 방식을 사용할 수 있습니다. 프로미스는 비동기 작업의 결과를 처리하고 관리하기 위한 객체입니다. 프로미스를 사용하면 비동기 작업의 성공, 실패, 또는 진행 중 상태를 효과적으로 다룰 수 있습니다.</p>
<pre><code class="language-js">
{
    let data = true;
    const func = new Promise((resolve, reject) => {
        if(data){
            resolve("45. 함수가 실행되었습니다.");
        } else {
            reject("45. 함수가 실행되지 않았습니다.");
        }
    });
    func
        .then(
            result => console.log(result)
        )
        .catch(
            error => console.log(error)
        )

    // 콜백지옥 --> 프로미스
    function funcA() {
        return new Promise((resolve) => {
            setTimeout(() => {
                console.log("funcA가 실행되었습니다.");
                resolve();
            }, 1000);
        })
    }
    function funcB() {
        return new Promise((resolve) => {
            setTimeout(() => {
                console.log("funcB가 실행되었습니다.");
                resolve();
            }, 1000);
        })
    }
    function funcC() {
        return new Promise((resolve) => {
            setTimeout(() => {
                console.log("funcC가 실행되었습니다.");
                resolve();
            }, 1000);
        })
    }
    function funcD() {
        return new Promise((resolve) => {
            setTimeout(() => {
                console.log("funcD가 실행되었습니다.");
                resolve();
            }, 1000);
        })
    }
    funcA()
        .then(funcB)
        .then(funcC)
        .then(funcD)
        .catch((error) => {
            console.log(error)
        })
}
</code></pre>
                    <p class="desc">
                        func 프로미스는 data 변수에 따라 resolve 또는 reject를 호출하여 상태를 변경합니다. .then()을 사용하여 성공적으로 완료된 경우 result를 출력하고, .catch()를 사용하여 에러가 발생한 경우 error를 출력합니다. data 변수가 true로 설정되었으므로 resolve가 호출됩니다. 따라서 "45. 함수가 실행되었습니다."라는 메시지가 출력됩니다.<br>
                        콜백 지옥 : funcA, funcB, funcC, funcD 함수는 각각 1초 후에 프로미스를 해결(resolve)합니다. 이러한 프로미스를 .then() 메서드를 사용하여 순차적으로 연결하여 비동기 작업이 순차적으로 실행되도록 합니다. .catch()를 사용하여 어떤 단계에서라도 에러가 발생한 경우 에러를 처리할 수 있습니다. funcA, funcB, funcC, funcD 함수는 각각 1초 후에 순차적으로 실행됩니다. 각 함수가 실행될 때 "funcX가 실행되었습니다."라는 메시지가 출력됩니다. 전체적으로는 1초 간격으로 함수가 실행되므로 다음과 같은 순서로 메시지가 출력됩니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                45. 함수가 실행되었습니다.<br>
                                funcA가 실행되었습니다.<br>
                                funcB가 실행되었습니다.<br>
                                funcC가 실행되었습니다.<br>
                                funcD가 실행되었습니다.
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample25-->

                <div id="sample26" class="sample">
                    <h3>26. 함수 : 비동기 함수 : asyne/await</h3>
                    <p>async/await는 JavaScript에서 비동기 작업을 더 쉽게 다룰 수 있게 해주는 기능입니다. 이를 사용하면 비동기 코드를 동기식처럼 작성할 수 있으며, 코드의 가독성을 향상시킬 수 있습니다.</p>
<pre><code class="language-js">
{
    // 01
    function func() {
        console.log("46. 함수가 실행되었습니다.");
    }
    func();

    // 02
    async function func2() {
        console.log("47. 함수가 실행되었습니다.");
    }
    func2();

    // 03
    async function func3() {
        const result = await fetch("https://webstoryboy.github.io/webs2024/json/gineungsaJC2011_05.json")
        const data = await result.json();
        console.log(data)
    }
    func3();

    // 04
    async function func4() {
        try {
            const result = await fetch("https://webstoryboy.github.io/webs2024/json/gineungsaJC2011_05.json")
            const data = await result.json();
            console.log(data)
        } catch (error){
            console.log(error);
        }
    }
    func4();
}
</code></pre>
                    <p class="desc">
                        01. 동기 함수 func를 정의하고, 함수가 호출되면 "함수가 실행되었습니다."라는 메시지를 콘솔에 출력합니다. func 함수가 정의된 후 즉시 호출됩니다.<br>
                        02. 동기 함수 func2를 정의합니다. func2 함수도 "함수가 실행되었습니다." 메시지를 출력하지만, 비동기 함수로 정의되었으므로 호출된 후에 다른 비동기 작업을 기다리지 않고 바로 실행됩니다. 비동기 함수는 일반 함수와 마찬가지로 호출됩니다.<br>
                        03. 비동기 함수 func3를 정의합니다. 이 함수는 웹에서 데이터를 가져오는 비동기 작업을 수행합니다. fetch 함수를 사용하여 웹 리소스를 요청하고 await 키워드를 사용하여 이 작업이 완료될 때까지 기다립니다. 그런 다음, 응답 데이터를 JSON으로 변환하고 결과를 콘솔에 출력합니다. 이 함수는 호출된 후 비동기적으로 실행됩니다.<br>
                        04. 비동기 함수 func4를 정의하며, try와 catch 블록을 사용하여 예외 처리를 구현합니다. 함수 내에서 데이터를 가져오는 것은 이전과 동일하지만, try 블록 내에서 작업을 시도하고 작업 중 발생한 에러가 있다면 catch 블록에서 에러를 처리하고 에러 메시지를 콘솔에 출력합니다. 이렇게 하면 예외가 발생해도 전체 프로그램이 중단되지 않고 제어가 catch 블록으로 이동합니다.
                    </p>
                    <div class="result">
                        <details>
                            <summary>결과 확인하기</summary>
                            <div>
                                46. 함수가 실행되었습니다.<br>
                                47. 함수가 실행되었습니다.<br>
                            </div>
                        </details>
                    </div>
                </div>
                <!-- // sample26-->



            </div>
            <!-- // main__sample -->
        </main>
        <!-- //main -->

        <footer id="footer">
            <a href="mailto:hongjihyeon1004@gmail.com">hongjihyeon1004@gmail.com</a>
        </footer>
        <!-- //footer -->

    </div>

    <!-- script -->
    <script src="../assets/js/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script>
        // 01. 함수 : 선언적 함수
        {
            function func() {
                console.log("1. 함수가 실행되었습니다.");
            }
            func();
        }

        // 02. 함수 : 익명 함수
        {
            const func = function () {
                console.log("2. 함수가 실행되었습니다.");
            }
            func();
        }

        // 03. 함수 : 매개변수 함수
        {
            function func(str) {
                console.log(str);
            }
            func("3. 함수가 실행되었습니다.");
        }

        // 04. 함수 : 리턴값 함수
        {
            function func() {
                return "4. 함수가 실행되었습니다.";
            }
            console.log(func());
        }

        // 05. 함수 : 매개변수 + 리턴값 함수
        {
            function func(str) {
                return str;
            }
            console.log(func("5. 함수가 실행되었습니다."));
        }

        // 06. 화살표 함수 : 선언적 함수
        {
            func = () => {
                console.log("6. 함수가 실행되었습니다.");
            }
            func();
        }

        // 07. 화살표 함수 : 익명 함수
        {
            const func = () => {
                console.log("7. 함수가 실행되었습니다.");
            }
            func();
        }

        // 08. 화살표 함수 : 매개변수 함수
        {
            func = (str) => {
                console.log(str);
            }
            func("8. 함수가 실행되었습니다.");
        }

        // 09. 화살표 함수 : 리턴값 함수
        {
            func = () => {
                return "9. 함수가 실행되었습니다.";
            }
            console.log(func());
        }

        // 10. 화살표 함수 : 익명 함수 + 매개변수 + 리턴값 함수
        {
            const func = (str) => {
                return str;
            }
            console.log(func("10. 함수가 실행되었습니다."));
        }

        // 11. 함수 유형 : 함수와 매개변수를 이용한 형태
        {
            function func(num, str) {
                console.log(num + ". " + str);
                console.log(`${num}. ${str}`);
            }
            func(11, "함수가 실행되었습니다.");
        }

        // 12. 함수 유형 : 함수와 변수를 이용한 형태
        {
            const num = 12;
            const str = "함수가 실행되었습니다.";

            function func(num, str) {
                console.log(`${num}. ${str}`);
            }
            func(num, str);
        }

        // 13. 함수 유형 : 함수와 배열을 이용한 형태
        {
            const num = [13, 14];
            const str = ["함수가 실행되었습니다.", "함수가 실행되었습니다."];

            function func(num, str) {
                console.log(`${num}. ${str}`);
            }
            func(num[0], str[0]);
            func(num[1], str[1]);
        }

        // 14. 함수 유형 : 함수와 객체를 이용한 형태
        {
            const info = {
                num: 15,
                str: "함수가 실행되었습니다."
            }
            function func(num, str) {
                console.log(`${num}. ${str}`);
            }
            func(info.num, info.str);
        }

        // 15. 함수 유형 : 함수와 객체 및 배열을 이용한 형태
        {
            const info = [
                { num: 16, str: "함수가 실행되었습니다." },
                { num: 17, str: "함수가 실행되었습니다." },
            ];
            function func(num, str) {
                console.log(`${num}. ${str}`);
            }
            func(info[0].num, info[0].str);
            func(info[1].num, info[1].str);
        }

        // 16. 함수 유형 : 객체 안에 함수를 이용한 형태
        {
            const info = {
                num: 18,
                str: "함수가 실행되었습니다.",
                result: () => {
                    console.log(`${info.num}. ${info.str}`);
                }
            }
            info.result();
        }

        // 17. 함수 유형 : 객체 생성자 함수
        {
            function Func(num, str) {
                this.num = num;
                this.str = str;
                this.result = () => {
                    console.log(`${this.num}. ${this.str}`);
                }
            }

            // 인스턴스 생성
            const info1 = new Func(19, "함수가 실행되었습니다.");
            const info2 = new Func(20, "함수가 실행되었습니다.");

            // 호출
            info1.result();
            info2.result();
        }

        // 18. 함수 유형 : 프로토타입 함수
        {
            function Func(num, str) {
                this.num = num;
                this.str = str;
            }

            Func.prototype.result = function () {
                console.log(`${this.num}. ${this.str}`);
            }

            const info1 = new Func(21, "함수가 실행되었습니다.");
            const info2 = new Func(22, "함수가 실행되었습니다.");

            info1.result();
            info2.result();
        }

        // 19. 함수 유형 : 객체 리터럴 함수
        {
            function Func(num, str) {
                this.num = num;
                this.str = str;
            }

            Func.prototype = {
                result1: function () {
                    console.log(`${this.num}. ${this.str}`);
                },
                result2: function () {
                    console.log(`${this.num}. ${this.str}`);
                }
            }

            const info1 = new Func(23, "함수가 실행되었습니다.");
            const info2 = new Func(24, "함수가 실행되었습니다.");

            info1.result1();
            info2.result2();
        }

        // 20. 함수 : 즉시실행 함수
        {
            (function () {
                console.log("25. 함수가 실행되었습니다.");
            })();
        }

        {
            (() => {
                console.log("26. 함수가 실행되었습니다.");
            })();
        }

        // 21. 함수 : 파라미터 함수
        {
            function func(str = "27. 함수가 실행되었습니다.") {
                console.log(str);
            }
            func();

            const func1 = (str = "28. 함수가 실행되었습니다.") => {
                console.log(str);
            }
            func1();
        }

        // 22. 함수 : 재귀 함수 : 자기 자신을 호출하는 함수
        {
            function func(num) {
                for (let i = 1; i <= num; i++) {
                    console.log("29. 함수가 실행되었습니다.");
                }
            }
            func(10);

            function func1(num) {
                if (num < 1) return;

                console.log("30. 함수가 실행되었습니다.");
                func1(num - 1);
            }
            func1(10);
        }

        // 23. 함수 : 콜백 함수 : 다른 함수로 실행되는 함수
        {
            // 01. 이벤트 콜백 함수
            // function func(){
            //     console.log("31. 함수가 실행되었습니다.");
            // }
            // btn.addEventListerner("click", func);

            // 02. 함수를 다른 함수의 인자로 전달
            function func1() {
                console.log("32. 함수가 실행되었습니다.");
            }
            function func2(callback) {
                callback();
                // func1();
            }
            func2(func1);

            // 03. 반복문으로 콜백함수 만들기
            function func3(num) {
                console.log(num + ". 함수가 실행되었습니다.");
            }
            function func4(callback) {
                for (let i = 33; i <= 38; i++) {
                    callback(i);
                }
            }
            func4(func3);
        }

        // 24. 함수 : 비동기 함수 : 콜백 함수
        {
            // 01. 동기적인 함수 호출
            // function func1() {
            //     console.log("39. 함수가 실행되었습니다.");
            // }
            // function func2() {
            //     console.log("40. 함수가 실행되었습니다.");
            // }
            // func1();
            // func2();
            // 41. 함수가 실행되었습니다.
            // 42. 함수가 실행되었습니다.

            // 02. 비동기적인 함수 호출
            // function func3() {
            //     setTimeout(() => {
            //         console.log("41. 함수가 실행되었습니다.");
            //     }, 1000);
            // }
            // function func4() {
            //     console.log("42. 함수가 실행되었습니다.");
            // }
            // func3();
            // func4();
            // 42. 함수가 실행되었습니다.
            // 41. 함수가 실행되었습니다.

            // 03. 비동기적인 콜백 함수 호출
            // {
            //     function func5(callback) {
            //         setTimeout(() => {
            //             console.log("43. 함수가 실행되었습니다.");
            //             callback();
            //         }, 1000);
            //     }
            //     function func6() {
            //         console.log("44. 함수가 실행되었습니다.");
            //     }
            //     func5(function () {
            //         func6();
            //     });
            // }

            // 콜백 지우기
            // {
            //     function funcA(callback){
            //         setTimeout(() => {
            //             console.log("funcA가 실행되었습니다.");
            //             callback();
            //         }, 1000);
            //     }
            //     function funcB(callback){
            //         setTimeout(() => {
            //             console.log("funcB가 실행되었습니다.");
            //             callback();
            //         }, 1000);
            //     }
            //     function funcC(callback){
            //         setTimeout(() => {
            //             console.log("funcC가 실행되었습니다.");
            //             callback();
            //         }, 1000);
            //     }
            //     function funcD(){
            //         setTimeout(() => {
            //             console.log("funcD가 실행되었습니다.");
            //         }, 1000);
            //     }
            //     funcA(function(){
            //         funcB(function(){
            //             funcC(function(){
            //                 funcD();
            //             });
            //         });
            //     });
            // }
        }
        // 25. 함수 : 비동기 함수 : 프로미스
        {
            // let data = true;
            // const func = new Promise((resolve, reject) => {
            //     if(data){
            //         resolve("45. 함수가 실행되었습니다.");
            //     } else {
            //         reject("45. 함수가 실행되지 않았습니다.");
            //     }
            // });
            // func
            //     .then(
            //         result => console.log(result)
            //     )
            //     .catch(
            //         error => console.log(error)
            //     )

            // 콜백지옥 --> 프로미스
            // function funcA() {
            //     return new Promise((resolve) => {
            //         setTimeout(() => {
            //             console.log("funcA가 실행되었습니다.");
            //             resolve();
            //         }, 1000);
            //     })
            // }
            // function funcB() {
            //     return new Promise((resolve) => {
            //         setTimeout(() => {
            //             console.log("funcB가 실행되었습니다.");
            //             resolve();
            //         }, 1000);
            //     })
            // }
            // function funcC() {
            //     return new Promise((resolve) => {
            //         setTimeout(() => {
            //             console.log("funcC가 실행되었습니다.");
            //             resolve();
            //         }, 1000);
            //     })
            // }
            // function funcD() {
            //     return new Promise((resolve) => {
            //         setTimeout(() => {
            //             console.log("funcD가 실행되었습니다.");
            //             resolve();
            //         }, 1000);
            //     })
            // }
            // funcA()
            //     .then(funcB)
            //     .then(funcC)
            //     .then(funcD)
            //     .catch((error) => {
            //         console.log(error)
            //     })
        }

        // 26. 함수 : 비동기 함수 : asyne/await
        {
            // 01
            function func() {
                console.log("46. 함수가 실행되었습니다.");
            }
            func();

            // 02
            async function func2() {
                console.log("47. 함수가 실행되었습니다.");
            }
            func2();

            // 03
            async function func3() {
                const result = await fetch("https://webstoryboy.github.io/webs2024/json/gineungsaJC2011_05.json")
                const data = await result.json();
                console.log(data)
            }
            func3();

            // 04
            async function func4() {
                try {
                    const result = await fetch("https://webstoryboy.github.io/webs2024/json/gineungsaJC2011_05.json")
                    const data = await result.json();
                    console.log(data)
                } catch (error){
                    console.log(error);
                }
            }
            func4();
        }
        // 27. 함수 : 중첩 함수
        // 28. 함수 : 클로저
        // 29. 클래스 : 기본
        // 30. 클래스 : 상속

    </script>
</body>

</html>